#!/usr/bin/env python3
"""
Multi-Agent Claude Code Orchestrator for Windows
리드: Claude Opus 4 (계획 및 조율)
서브: Claude Sonnet 4 (실행)
"""

import subprocess
import json
import time
import os
from datetime import datetime
from typing import Dict, List, Optional
import threading
import queue
import sys


class ClaudeOrchestrator:
    def __init__(self):
        self.lead_model = "opus"  # Claude Opus 4
        self.worker_model = "sonnet"  # Claude Sonnet 4
        self.task_queue = queue.Queue()
        self.results_queue = queue.Queue()
        self.active_agents = {}
        self.project_root = r"C:\Git\Routine_app"

    def setup_worktrees(self, num_workers: int = 3):
        """Git worktree 설정 - Windows 경로"""
        base_branch = "main"

        # 먼저 현재 상태 커밋
        subprocess.run(["git", "add", "."], cwd=self.project_root)
        subprocess.run(["git", "commit", "-m", "Save current state"], cwd=self.project_root)

        for i in range(num_workers):
            worktree_name = f"worker-{i + 1}"
            # Windows 경로 형식
            worktree_path = os.path.join(os.path.dirname(self.project_root), worktree_name)

            if not os.path.exists(worktree_path):
                # 브랜치가 없으면 생성
                branch_name = f"feature/{worktree_name}"
                subprocess.run([
                    "git", "branch", branch_name
                ], cwd=self.project_root, capture_output=True)

                # Worktree 추가
                subprocess.run([
                    "git", "worktree", "add",
                    worktree_path,
                    branch_name
                ], cwd=self.project_root, capture_output=True)

                print(f"✅ Created worktree: {worktree_path}")

    def create_plan(self, project_description: str) -> Dict:
        """Opus 4로 프로젝트 계획 생성"""
        print("🧠 Claude Opus 4가 프로젝트를 분석하고 계획을 수립합니다...")

        plan_prompt = f"""
        다음 프로젝트를 분석하고 병렬로 실행할 수 있는 작업들로 분해해주세요:

        {project_description}

        다음 형식으로 JSON을 반환해주세요:
        {{
            "tasks": [
                {{
                    "id": "task-1",
                    "name": "작업 이름",
                    "description": "상세 설명",
                    "dependencies": [],
                    "estimated_time": "30m",
                    "priority": 1
                }}
            ]
        }}
        """

        # Opus 4로 계획 생성
        result = subprocess.run([
            "claude", "-p", plan_prompt,
            "--model", self.lead_model,
            "--output-format", "json"
        ], capture_output=True, text=True, shell=True, cwd=self.project_root)

        try:
            # JSON 응답에서 실제 JSON 부분만 추출
            stdout = result.stdout
            # JSON 시작 위치 찾기
            json_start = stdout.find('{')
            json_end = stdout.rfind('}') + 1

            if json_start != -1 and json_end > json_start:
                json_str = stdout[json_start:json_end]
                plan_data = json.loads(json_str)
            else:
                raise json.JSONDecodeError("No JSON found", stdout, 0)

            # PLAN.md 파일 생성
            plan_path = os.path.join(self.project_root, "PLAN.md")
            with open(plan_path, "w", encoding='utf-8') as f:
                f.write(f"# Project Plan\n\n")
                f.write(f"Generated by Claude Opus 4 at {datetime.now()}\n\n")
                f.write(f"## Tasks\n\n")

                for task in plan_data.get("tasks", []):
                    f.write(f"### {task['name']}\n")
                    f.write(f"- **ID**: {task['id']}\n")
                    f.write(f"- **Description**: {task['description']}\n")
                    f.write(f"- **Priority**: {task['priority']}\n")
                    f.write(f"- **Estimated Time**: {task.get('estimated_time', 'N/A')}\n\n")

            return plan_data

        except json.JSONDecodeError as e:
            print(f"⚠️ 계획 생성 실패: {e}")
            print(f"응답: {result.stdout}")
            return self.get_default_plan()

    def execute_task(self, task: Dict, worktree_id: int):
        """Sonnet 4로 개별 작업 실행"""
        worktree_path = os.path.join(os.path.dirname(self.project_root), f"worker-{worktree_id}")
        task_id = task['id']

        print(f"🚀 Worker {worktree_id} (Sonnet 4): {task['name']} 시작")

        # Windows PowerShell 명령
        cmd = [
            "claude", "-p", f"다음 작업을 구현해주세요: {task['description']}",
            "--model", self.worker_model,
            "--allowedTools", "Write", "Bash(*)",
            "--dangerously-skip-permissions"
        ]

        process = subprocess.Popen(
            cmd,
            cwd=worktree_path,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            shell=True
        )

        self.active_agents[task_id] = {
            "process": process,
            "worktree": worktree_id,
            "start_time": time.time()
        }

        # 결과 대기 (별도 스레드에서)
        def wait_for_completion():
            stdout, stderr = process.communicate()
            duration = time.time() - self.active_agents[task_id]["start_time"]

            self.results_queue.put({
                "task_id": task_id,
                "worktree": worktree_id,
                "stdout": stdout,
                "stderr": stderr,
                "duration": duration,
                "success": process.returncode == 0
            })

            print(f"✅ Worker {worktree_id}: {task['name']} 완료 ({duration:.1f}초)")

        thread = threading.Thread(target=wait_for_completion)
        thread.start()

    def review_and_merge(self):
        """Opus 4로 결과 검토 및 병합"""
        print("\n🔍 Claude Opus 4가 모든 작업 결과를 검토합니다...")

        review_prompt = """
        모든 병렬 작업이 완료되었습니다. 
        각 worktree의 변경사항을 검토하고 통합해주세요.
        충돌을 해결하고 최종 코드를 main 브랜치에 병합해주세요.
        """

        subprocess.run([
            "claude", "-p", review_prompt,
            "--model", self.lead_model,
            "--allowedTools", "Write", "Bash(*)", "GitCommit"
        ], shell=True, cwd=self.project_root)

    def run(self, project_description: str):
        """전체 오케스트레이션 실행"""
        print("🎯 다중 에이전트 시스템 시작\n")
        print(f"프로젝트 경로: {self.project_root}\n")

        # 1. Worktree 설정
        self.setup_worktrees(3)

        # 2. Opus 4로 계획 수립
        plan = self.create_plan(project_description)

        # 3. 사용자 확인
        input("\n계획을 확인하고 Enter를 눌러 계속하세요...")

        # 4. Sonnet 4 인스턴스들로 병렬 실행
        tasks = plan.get("tasks", [])
        for i, task in enumerate(tasks[:3]):  # 최대 3개 병렬
            self.execute_task(task, i + 1)
            time.sleep(2)  # 시작 간격

        # 5. 모든 작업 완료 대기
        completed = 0
        while completed < len(tasks[:3]):
            try:
                result = self.results_queue.get(timeout=1)
                completed += 1
                print(f"\n📊 진행률: {completed}/{len(tasks[:3])}")
            except queue.Empty:
                continue

        # 6. Opus 4로 최종 검토 및 병합
        self.review_and_merge()

        print("\n✨ 다중 에이전트 작업 완료!")

    def get_default_plan(self) -> Dict:
        """기본 계획 템플릿"""
        return {
            "tasks": [
                {
                    "id": "backend",
                    "name": "백엔드 API 개발",
                    "description": "RESTful API 구현 (FastAPI)",
                    "dependencies": [],
                    "priority": 1
                },
                {
                    "id": "frontend",
                    "name": "프론트엔드 개발",
                    "description": "React UI 구현",
                    "dependencies": [],
                    "priority": 1
                },
                {
                    "id": "testing",
                    "name": "테스트 작성",
                    "description": "단위 테스트 및 통합 테스트",
                    "dependencies": ["backend", "frontend"],
                    "priority": 2
                }
            ]
        }


# 실행 스크립트
if __name__ == "__main__":
    orchestrator = ClaudeOrchestrator()

    # Routine_app 프로젝트에 맞는 작업 설명
    project = """
    Routine_app 기능 개선 및 확장
    - 사용자 루틴 관리 시스템 강화
    - 알림 기능 구현
    - 데이터 시각화 대시보드
    - API 성능 최적화
    """

    orchestrator.run(project)