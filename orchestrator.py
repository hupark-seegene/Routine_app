#!/usr/bin/env python3
"""
Multi-Agent Claude Code Orchestrator for Windows
ë¦¬ë“œ: Claude Opus 4 (ê³„íš ë° ì¡°ìœ¨)
ì„œë¸Œ: Claude Sonnet 4 (ì‹¤í–‰)
"""

import subprocess
import json
import time
import os
from datetime import datetime
from typing import Dict, List, Optional
import threading
import queue
import sys


class ClaudeOrchestrator:
    def __init__(self):
        self.lead_model = "opus"  # Claude Opus 4
        self.worker_model = "sonnet"  # Claude Sonnet 4
        self.task_queue = queue.Queue()
        self.results_queue = queue.Queue()
        self.active_agents = {}
        self.project_root = r"C:\Git\Routine_app"

    def setup_worktrees(self, num_workers: int = 3):
        """Git worktree ì„¤ì • - Windows ê²½ë¡œ"""
        base_branch = "main"

        # ë¨¼ì € í˜„ì¬ ìƒíƒœ ì»¤ë°‹
        subprocess.run(["git", "add", "."], cwd=self.project_root)
        subprocess.run(["git", "commit", "-m", "Save current state"], cwd=self.project_root)

        for i in range(num_workers):
            worktree_name = f"worker-{i + 1}"
            # Windows ê²½ë¡œ í˜•ì‹
            worktree_path = os.path.join(os.path.dirname(self.project_root), worktree_name)

            if not os.path.exists(worktree_path):
                # ë¸Œëœì¹˜ê°€ ì—†ìœ¼ë©´ ìƒì„±
                branch_name = f"feature/{worktree_name}"
                subprocess.run([
                    "git", "branch", branch_name
                ], cwd=self.project_root, capture_output=True)

                # Worktree ì¶”ê°€
                subprocess.run([
                    "git", "worktree", "add",
                    worktree_path,
                    branch_name
                ], cwd=self.project_root, capture_output=True)

                print(f"âœ… Created worktree: {worktree_path}")

    def create_plan(self, project_description: str) -> Dict:
        """Opus 4ë¡œ í”„ë¡œì íŠ¸ ê³„íš ìƒì„±"""
        print("ğŸ§  Claude Opus 4ê°€ í”„ë¡œì íŠ¸ë¥¼ ë¶„ì„í•˜ê³  ê³„íšì„ ìˆ˜ë¦½í•©ë‹ˆë‹¤...")

        plan_prompt = f"""
        ë‹¤ìŒ í”„ë¡œì íŠ¸ë¥¼ ë¶„ì„í•˜ê³  ë³‘ë ¬ë¡œ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ì‘ì—…ë“¤ë¡œ ë¶„í•´í•´ì£¼ì„¸ìš”:

        {project_description}

        ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ JSONì„ ë°˜í™˜í•´ì£¼ì„¸ìš”:
        {{
            "tasks": [
                {{
                    "id": "task-1",
                    "name": "ì‘ì—… ì´ë¦„",
                    "description": "ìƒì„¸ ì„¤ëª…",
                    "dependencies": [],
                    "estimated_time": "30m",
                    "priority": 1
                }}
            ]
        }}
        """

        # Opus 4ë¡œ ê³„íš ìƒì„±
        result = subprocess.run([
            "claude", "-p", plan_prompt,
            "--model", self.lead_model,
            "--output-format", "json"
        ], capture_output=True, text=True, shell=True, cwd=self.project_root)

        try:
            # JSON ì‘ë‹µì—ì„œ ì‹¤ì œ JSON ë¶€ë¶„ë§Œ ì¶”ì¶œ
            stdout = result.stdout
            # JSON ì‹œì‘ ìœ„ì¹˜ ì°¾ê¸°
            json_start = stdout.find('{')
            json_end = stdout.rfind('}') + 1

            if json_start != -1 and json_end > json_start:
                json_str = stdout[json_start:json_end]
                plan_data = json.loads(json_str)
            else:
                raise json.JSONDecodeError("No JSON found", stdout, 0)

            # PLAN.md íŒŒì¼ ìƒì„±
            plan_path = os.path.join(self.project_root, "PLAN.md")
            with open(plan_path, "w", encoding='utf-8') as f:
                f.write(f"# Project Plan\n\n")
                f.write(f"Generated by Claude Opus 4 at {datetime.now()}\n\n")
                f.write(f"## Tasks\n\n")

                for task in plan_data.get("tasks", []):
                    f.write(f"### {task['name']}\n")
                    f.write(f"- **ID**: {task['id']}\n")
                    f.write(f"- **Description**: {task['description']}\n")
                    f.write(f"- **Priority**: {task['priority']}\n")
                    f.write(f"- **Estimated Time**: {task.get('estimated_time', 'N/A')}\n\n")

            return plan_data

        except json.JSONDecodeError as e:
            print(f"âš ï¸ ê³„íš ìƒì„± ì‹¤íŒ¨: {e}")
            print(f"ì‘ë‹µ: {result.stdout}")
            return self.get_default_plan()

    def execute_task(self, task: Dict, worktree_id: int):
        """Sonnet 4ë¡œ ê°œë³„ ì‘ì—… ì‹¤í–‰"""
        worktree_path = os.path.join(os.path.dirname(self.project_root), f"worker-{worktree_id}")
        task_id = task['id']

        print(f"ğŸš€ Worker {worktree_id} (Sonnet 4): {task['name']} ì‹œì‘")

        # Windows PowerShell ëª…ë ¹
        cmd = [
            "claude", "-p", f"ë‹¤ìŒ ì‘ì—…ì„ êµ¬í˜„í•´ì£¼ì„¸ìš”: {task['description']}",
            "--model", self.worker_model,
            "--allowedTools", "Write", "Bash(*)",
            "--dangerously-skip-permissions"
        ]

        process = subprocess.Popen(
            cmd,
            cwd=worktree_path,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            shell=True
        )

        self.active_agents[task_id] = {
            "process": process,
            "worktree": worktree_id,
            "start_time": time.time()
        }

        # ê²°ê³¼ ëŒ€ê¸° (ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ)
        def wait_for_completion():
            stdout, stderr = process.communicate()
            duration = time.time() - self.active_agents[task_id]["start_time"]

            self.results_queue.put({
                "task_id": task_id,
                "worktree": worktree_id,
                "stdout": stdout,
                "stderr": stderr,
                "duration": duration,
                "success": process.returncode == 0
            })

            print(f"âœ… Worker {worktree_id}: {task['name']} ì™„ë£Œ ({duration:.1f}ì´ˆ)")

        thread = threading.Thread(target=wait_for_completion)
        thread.start()

    def review_and_merge(self):
        """Opus 4ë¡œ ê²°ê³¼ ê²€í†  ë° ë³‘í•©"""
        print("\nğŸ” Claude Opus 4ê°€ ëª¨ë“  ì‘ì—… ê²°ê³¼ë¥¼ ê²€í† í•©ë‹ˆë‹¤...")

        review_prompt = """
        ëª¨ë“  ë³‘ë ¬ ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. 
        ê° worktreeì˜ ë³€ê²½ì‚¬í•­ì„ ê²€í† í•˜ê³  í†µí•©í•´ì£¼ì„¸ìš”.
        ì¶©ëŒì„ í•´ê²°í•˜ê³  ìµœì¢… ì½”ë“œë¥¼ main ë¸Œëœì¹˜ì— ë³‘í•©í•´ì£¼ì„¸ìš”.
        """

        subprocess.run([
            "claude", "-p", review_prompt,
            "--model", self.lead_model,
            "--allowedTools", "Write", "Bash(*)", "GitCommit"
        ], shell=True, cwd=self.project_root)

    def run(self, project_description: str):
        """ì „ì²´ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ ì‹¤í–‰"""
        print("ğŸ¯ ë‹¤ì¤‘ ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ ì‹œì‘\n")
        print(f"í”„ë¡œì íŠ¸ ê²½ë¡œ: {self.project_root}\n")

        # 1. Worktree ì„¤ì •
        self.setup_worktrees(3)

        # 2. Opus 4ë¡œ ê³„íš ìˆ˜ë¦½
        plan = self.create_plan(project_description)

        # 3. ì‚¬ìš©ì í™•ì¸
        input("\nê³„íšì„ í™•ì¸í•˜ê³  Enterë¥¼ ëˆŒëŸ¬ ê³„ì†í•˜ì„¸ìš”...")

        # 4. Sonnet 4 ì¸ìŠ¤í„´ìŠ¤ë“¤ë¡œ ë³‘ë ¬ ì‹¤í–‰
        tasks = plan.get("tasks", [])
        for i, task in enumerate(tasks[:3]):  # ìµœëŒ€ 3ê°œ ë³‘ë ¬
            self.execute_task(task, i + 1)
            time.sleep(2)  # ì‹œì‘ ê°„ê²©

        # 5. ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
        completed = 0
        while completed < len(tasks[:3]):
            try:
                result = self.results_queue.get(timeout=1)
                completed += 1
                print(f"\nğŸ“Š ì§„í–‰ë¥ : {completed}/{len(tasks[:3])}")
            except queue.Empty:
                continue

        # 6. Opus 4ë¡œ ìµœì¢… ê²€í†  ë° ë³‘í•©
        self.review_and_merge()

        print("\nâœ¨ ë‹¤ì¤‘ ì—ì´ì „íŠ¸ ì‘ì—… ì™„ë£Œ!")

    def get_default_plan(self) -> Dict:
        """ê¸°ë³¸ ê³„íš í…œí”Œë¦¿"""
        return {
            "tasks": [
                {
                    "id": "backend",
                    "name": "ë°±ì—”ë“œ API ê°œë°œ",
                    "description": "RESTful API êµ¬í˜„ (FastAPI)",
                    "dependencies": [],
                    "priority": 1
                },
                {
                    "id": "frontend",
                    "name": "í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ",
                    "description": "React UI êµ¬í˜„",
                    "dependencies": [],
                    "priority": 1
                },
                {
                    "id": "testing",
                    "name": "í…ŒìŠ¤íŠ¸ ì‘ì„±",
                    "description": "ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ë° í†µí•© í…ŒìŠ¤íŠ¸",
                    "dependencies": ["backend", "frontend"],
                    "priority": 2
                }
            ]
        }


# ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
if __name__ == "__main__":
    orchestrator = ClaudeOrchestrator()

    # Routine_app í”„ë¡œì íŠ¸ì— ë§ëŠ” ì‘ì—… ì„¤ëª…
    project = """
    Routine_app ê¸°ëŠ¥ ê°œì„  ë° í™•ì¥
    - ì‚¬ìš©ì ë£¨í‹´ ê´€ë¦¬ ì‹œìŠ¤í…œ ê°•í™”
    - ì•Œë¦¼ ê¸°ëŠ¥ êµ¬í˜„
    - ë°ì´í„° ì‹œê°í™” ëŒ€ì‹œë³´ë“œ
    - API ì„±ëŠ¥ ìµœì í™”
    """

    orchestrator.run(project)